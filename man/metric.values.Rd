% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/metric.values.R
\name{metric.values}
\alias{metric.values}
\title{Calculate metric values}
\usage{
metric.values(fun.DF, fun.Community, fun.MetricNames = NULL,
  boo.Adjust = FALSE)
}
\arguments{
\item{fun.DF}{Data frame of taxa (list required fields)}

\item{fun.Community}{Community name for which to calculate metric values (bugs, fish, or algae)}

\item{fun.MetricNames}{Optional vector of metric names to be returned.  If none are supplied then all will be returned.}

\item{boo.Adjust}{Optional boolean value on whether to perform adjustments of values prior to scoring.  Default = FALSE but will always be TRUE for fish metrics.}
}
\value{
data frame of SampleID and metric values
}
\description{
This function calculates metric values for bugs and fish.
Inputs are a data frame with SampleID and taxa with phylogenetic and autecological information
(see below for required fields by community).  The dplyr package is used to generate the metric values.
}
\details{
No manipulations of the taxa are performed by this routine.  
All benthic macroinvertebrate taxa should be identified to genus level.  
Any non-count taxa should be identified in the "Exclude" field as "TRUE". 

Required Fields:

* SAMPLEID

* TAXAID

* N_TAXA

* EXCLUDE

* SITETYPE

* NONTARGET

* PHYLUM, CLASS, ORDER, FAMILY, SUBFAMILY, GENUS

* FFG, HABIT, LIFE_CYCLE, TOLVAL, BCG_ATTR

Valid values for FFG: col, fil, pre, scr, shr

Valid values for HABIT: BU, CB, CN, SP, SW
}
\examples{
# PACIFIC NW BCG

library(readxl)

df.samps.bugs <- read_excel(system.file("./extdata/Data_BCG_PacNW.xlsx"
                                       , package="BCGcalc"))
myDF <- df.samps.bugs

# Run Function
df.metric.values.bugs <- metric.values(myDF, "bugs")

# View Results
View(df.metric.values.bugs)

# Get data in long format so can QC results more easily
df.long <- reshape2::melt(df.metric.values.bugs, id.vars=c("SAMPLEID", "INDEX_NAME", "SITETYPE")
                          , variable.name="metric.name", value.name="metric.value")
# Save Results
write.table(df.long, "metric.values.tsv", col.names=TRUE, row.names=FALSE, sep="\\t")

# DataExplorer Report
library(DataExplorer)
create_report(df.metric.values.bugs, "DataExplorer_Report_MetricValues.html")
create_report(df.samps.bugs, "DataExplorer_Report_BugSamples.html")

#~~~~~~~~~~~~~~~~~~~~~~~
# INDIANA BCG

library(readxl)

df.samps.bugs <- read_excel(system.file("./extdata/Data_BCG_Indiana.xlsx"
                           , package="BCGcalc"), sheet="R_Input")
dim(df.samps.bugs) 
# rename some fields 
names(df.samps.bugs)
names(df.samps.bugs)[names(df.samps.bugs)=="VisitNum"] <- "SampleID"
names(df.samps.bugs)[names(df.samps.bugs)=="FinalID"] <- "TaxaID"
names(df.samps.bugs)[names(df.samps.bugs)=="Count"] <- "N_Taxa"
# Add field
df.samps.bugs[, "INDEX_NAME"] <- "BCG.IN"
#
# Run Function
myDF <- df.samps.bugs
df.metric.values.bugs <- metric.values(myDF, "bugs")

# View Results
View(df.metric.values.bugs)

# Get data in long format so can QC results more easily
df.long <- reshape2::melt(df.metric.values.bugs, id.vars=c("SAMPLEID", "INDEX_NAME", "SITETYPE")
                          , variable.name="metric.name", value.name="metric.value")
# Save Results
write.table(df.long, "metric.values.tsv", col.names=TRUE, row.names=FALSE, sep="\\t")

# DataExplorer Report
library(DataExplorer)
create_report(df.metric.values.bugs, "DataExplorer_Report_MetricValues.html")
create_report(df.samps.bugs, "DataExplorer_Report_BugSamples.html")

}
