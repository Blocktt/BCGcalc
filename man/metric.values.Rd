% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/metric.values.R
\name{metric.values}
\alias{metric.values}
\title{Calculate metric values}
\usage{
metric.values(fun.DF, fun.Community, fun.MetricNames = NULL,
  boo.Adjust = FALSE, fun.cols2keep = NULL)
}
\arguments{
\item{fun.DF}{Data frame of taxa (list required fields)}

\item{fun.Community}{Community name for which to calculate metric values (bugs, fish, or algae)}

\item{fun.MetricNames}{Optional vector of metric names to be returned.
If none are supplied then all will be returned.}

\item{boo.Adjust}{Optional boolean value on whether to perform adjustments of 
values prior to scoring.  Default = FALSE but will always be TRUE for fish metrics.}

\item{fun.cols2keep}{Column names of fun.DF to retain in the output.  Uses column names.}
}
\value{
data frame of SampleID and metric values
}
\description{
This function calculates metric values for bugs and fish.
Inputs are a data frame with SampleID and taxa with phylogenetic and autecological information
(see below for required fields by community).  The dplyr package is used to generate the metric values.
}
\details{
No manipulations of the taxa are performed by this routine.  
All benthic macroinvertebrate taxa should be identified to the appropriate 
operational taxonomic unit (OTU).  
Any non-count taxa should be identified in the "Exclude" field as "TRUE". 
These taxa will be excluded from taxa richness metrics (but will count for 
all others).  Excluded taxa are ambiguous taxa (on a sample basis), i.e., 
the parent taxa when child taxa are present.  For example, the parent taxa 
Chironomidae would be xcluded when the child taxa Tanytarsini is present.  
Both would be excluded when Tanytarsus is present.
Any non-target taxa should be identified in the "NonTarget" field as "TRUE". 
Non-target taxa are those that are not part of your intended capture list; 
e.g., fish,  herps, water column taxa, or water surface taxa in a benthic sample.
The target list will vary by program.
The non-target taxa will be removed prior to any calculations.
There are a number of required fields (see below) for metric to calculation.  
If any fields are missing the user will be prompted as to which are missing 
and if the user wants to continue or quit.  If the user continues the missing 
fields will be added but will be filled with zero or NA (as appropriate).  
Any metrics based on the missing fields will not be valid.

Required Fields:

* SAMPLEID (character or number, must be unique)

* TAXAID (character or number, must be unique)

* N_TAXA

* EXCLUDE (valid values are TRUE and FALSE)

* INDEX_NAME

* SITE_TYPE (BCG or MMI site category; e.g., for BCG PacNW valid values are "hi" or "lo")

* NONTARGET (valid values are TRUE and FALSE)

* PHYLUM, SUBPHYLUM, CLASS, ORDER, FAMILY, SUBFAMILY, TRIBE, GENUS

* FFG, HABIT, LIFE_CYCLE, TOLVAL, BCG_ATTR, THERMAL_INDICATOR

Valid values for FFG: CG, CF, PR, SC, SH

Valid values for HABIT: BU, CB, CN, SP, SW

Valid values for LIFE_CYCLE: UNI, SEMI, MULTI

Valid values for THERMAL_INDICATOR: COLD, COLD_COOL, COOL_WARM, WARM

Columns to keep are additional fields in the input file that the user wants 
retained in the output.  Fields need to be those that are unique per sample 
and not associated with the taxa.  For example, the fields used in qc.check();
Area_mi2, SurfaceArea, Density_m2, and Density_ft2.
}
\examples{
# PACIFIC NW BCG

library(readxl)

df.samps.bugs <- read_excel(system.file("./extdata/Data_BCG_PacNW.xlsx"
                                       , package="BCGcalc"))
myDF <- df.samps.bugs

# Columns to keep
myCols <- c("Area_mi2", "SurfaceArea", "Density_m2", "Density_ft2")

# Run Function
df.metric.values.bugs <- metric.values(myDF, "bugs", fun.cols2keep=myCols)

# View Results
View(df.metric.values.bugs)

# Get data in long format so can QC results more easily
df.long <- reshape2::melt(df.metric.values.bugs, id.vars=c("SAMPLEID", "INDEX_NAME"
                                                 , "SITE_TYPE", toupper(myCols))
                          , variable.name="METRIC_NAME", value.name="METRIC_VALUE")
# Save Results
write.table(df.long, "metric.values.tsv", col.names=TRUE, row.names=FALSE, sep="\\t")

# DataExplorer Report
library(DataExplorer)
create_report(df.metric.values.bugs, "DataExplorer_Report_MetricValues.html")
create_report(df.samps.bugs, "DataExplorer_Report_BugSamples.html")

#~~~~~~~~~~~~~~~~~~~~~~~
# INDIANA BCG

library(readxl)

df.samps.bugs <- read_excel(system.file("./extdata/Data_BCG_Indiana.xlsx"
                           , package="BCGcalc"), sheet="R_Input")
dim(df.samps.bugs) 
# rename some fields 
names(df.samps.bugs)
names(df.samps.bugs)[names(df.samps.bugs)=="VisitNum"] <- "SampleID"
names(df.samps.bugs)[names(df.samps.bugs)=="FinalID"] <- "TaxaID"
names(df.samps.bugs)[names(df.samps.bugs)=="Count"] <- "N_Taxa"
# Add field
df.samps.bugs[, "INDEX_NAME"] <- "BCG.IN"
#
# Run Function
myDF <- df.samps.bugs
df.metric.values.bugs <- metric.values(myDF, "bugs")

# View Results
View(df.metric.values.bugs)

# Get data in long format so can QC results more easily
df.long <- reshape2::melt(df.metric.values.bugs, id.vars=c("SAMPLEID", "INDEX_NAME", "SITE_TYPE")
                          , variable.name="METRIC_NAME", value.name="METRIC_VALUE")
# Save Results
write.table(df.long, "metric.values.tsv", col.names=TRUE, row.names=FALSE, sep="\\t")

# DataExplorer Report
library(DataExplorer)
create_report(df.metric.values.bugs, "DataExplorer_Report_MetricValues.html")
create_report(df.samps.bugs, "DataExplorer_Report_BugSamples.html")
}
