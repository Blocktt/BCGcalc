% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/metric.values.R
\name{metric.values}
\alias{metric.values}
\title{Calculate metric values}
\usage{
metric.values(fun.DF, fun.Community, fun.MetricNames = NULL,
  boo.Adjust = FALSE, fun.cols2keep = NULL)
}
\arguments{
\item{fun.DF}{Data frame of taxa (list required fields)}

\item{fun.Community}{Community name for which to calculate metric values (bugs, fish, or algae)}

\item{fun.MetricNames}{Optional vector of metric names to be returned.
If none are supplied then all will be returned.}

\item{boo.Adjust}{Optional boolean value on whether to perform adjustments of 
values prior to scoring.  Default = FALSE but will always be TRUE for fish metrics.}

\item{fun.cols2keep}{Column names of fun.DF to retain in the output.  Uses column names.}
}
\value{
data frame of SampleID and metric values
}
\description{
This function calculates metric values for bugs and fish.
Inputs are a data frame with SampleID and taxa with phylogenetic and autecological information
(see below for required fields by community).  The dplyr package is used to generate the metric values.
}
\details{
No manipulations of the taxa are performed by this routine.  
All benthic macroinvertebrate taxa should be identified to 
the appropriate operational taxonomic unit (OTU).  
Any non-count taxa should be identified in the "Exclude" field as "TRUE". 
These taxa will be excluded from taxa richness metrics (but will count for all others).  
Any non-target taxa should be identified in the "NonTarget" field as "TRUE".  
These taxa will be removed prior to any calculations.

Required Fields:

* SAMPLEID (character or number, must be unique)

* TAXAID (character or number, must be unique)

* N_TAXA

* EXCLUDE (valid values are TRUE and FALSE)

* SITE_TYPE (BCG or MMI site category; e.g., for BCG PacNW valid values are "hi" or "lo")

* NONTARGET (valid values are TRUE and FALSE)

* PHYLUM, CLASS, ORDER, FAMILY, SUBFAMILY, GENUS

* FFG, HABIT, LIFE_CYCLE, TOLVAL, BCG_ATTR

Valid values for FFG: CG, CF, PR, SC, SH

Valid values for HABIT: BU, CB, CN, SP, SW

Valid values for LIFE_CYCLE: UNI, SEMI, MULTI

Columns to keep are additional fields in the input file that the user wants retained
in the output.  Fields need to be those that are unique per sample and not associated with the taxa.
For example, the fields used in qc.check(); Area_mi2, SurfaceArea, Density_m2, and Density_ft2.
}
\examples{
# PACIFIC NW BCG

library(readxl)

df.samps.bugs <- read_excel(system.file("./extdata/Data_BCG_PacNW.xlsx"
                                       , package="BCGcalc"))
myDF <- df.samps.bugs

# Columns to keep
myCols <- c("Area_mi2", "SurfaceArea", "Density_m2", "Density_ft2")

# Run Function
df.metric.values.bugs <- metric.values(myDF, "bugs", fun.cols2keep=myCols)

# View Results
View(df.metric.values.bugs)

# Get data in long format so can QC results more easily
df.long <- reshape2::melt(df.metric.values.bugs, id.vars=c("SAMPLEID", "INDEX_NAME"
                                                 , "SITE_TYPE", toupper(myCols))
                          , variable.name="METRIC_NAME", value.name="METRIC_VALUE")
# Save Results
write.table(df.long, "metric.values.tsv", col.names=TRUE, row.names=FALSE, sep="\\t")

# DataExplorer Report
library(DataExplorer)
create_report(df.metric.values.bugs, "DataExplorer_Report_MetricValues.html")
create_report(df.samps.bugs, "DataExplorer_Report_BugSamples.html")

#~~~~~~~~~~~~~~~~~~~~~~~
# INDIANA BCG

library(readxl)

df.samps.bugs <- read_excel(system.file("./extdata/Data_BCG_Indiana.xlsx"
                           , package="BCGcalc"), sheet="R_Input")
dim(df.samps.bugs) 
# rename some fields 
names(df.samps.bugs)
names(df.samps.bugs)[names(df.samps.bugs)=="VisitNum"] <- "SampleID"
names(df.samps.bugs)[names(df.samps.bugs)=="FinalID"] <- "TaxaID"
names(df.samps.bugs)[names(df.samps.bugs)=="Count"] <- "N_Taxa"
# Add field
df.samps.bugs[, "INDEX_NAME"] <- "BCG.IN"
#
# Run Function
myDF <- df.samps.bugs
df.metric.values.bugs <- metric.values(myDF, "bugs")

# View Results
View(df.metric.values.bugs)

# Get data in long format so can QC results more easily
df.long <- reshape2::melt(df.metric.values.bugs, id.vars=c("SAMPLEID", "INDEX_NAME", "SITE_TYPE")
                          , variable.name="METRIC_NAME", value.name="METRIC_VALUE")
# Save Results
write.table(df.long, "metric.values.tsv", col.names=TRUE, row.names=FALSE, sep="\\t")

# DataExplorer Report
library(DataExplorer)
create_report(df.metric.values.bugs, "DataExplorer_Report_MetricValues.html")
create_report(df.samps.bugs, "DataExplorer_Report_BugSamples.html")
}
